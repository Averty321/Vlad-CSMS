<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор наклеек для приборов</title>
    <style>
        /* Все ваши оригинальные стили остаются без изменений */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f8ff;
            color: #003366;
            line-height: 1.6;
        }

        h1 {
            color: #005b96;
            text-align: center;
            margin-bottom: 25px;
            font-weight: 500;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0, 91, 150, 0.1);
            border: 1px solid #d1e3f6;
        }

        label {
            display: inline-block;
            width: 180px;
            margin-bottom: 12px;
            color: #005b96;
            font-weight: 500;
        }

        input, select {
            padding: 10px;
            width: 220px;
            margin-bottom: 12px;
            border: 1px solid #b8d4f0;
            border-radius: 4px;
            background-color: white;
            color: #003366;
        }

        button {
            padding: 10px 18px;
            margin-right: 12px;
            margin-top: 12px;
            cursor: pointer;
            background: #0077cc;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 91, 150, 0.1);
        }

        button:hover {
            background: #005fa3;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #b8d4f0;
            cursor: not-allowed;
            transform: none;
        }

        table {
            margin-top: 25px;
            border-collapse: collapse;
            width: 100%;
            background: white;
            box-shadow: 0 2px 10px rgba(0, 91, 150, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            border: 1px solid #d1e3f6;
            padding: 12px;
            text-align: center;
        }

        th {
            background-color: #0077cc;
            color: white;
            position: sticky;
            top: 0;
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: #f5faff;
        }

        .editable {
            background: #e6f2ff;
        }

        .group-header {
            background-color: #0077cc;
            color: white;
            padding: 15px;
            margin-top: 25px;
            border-radius: 8px 8px 0 0;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(0, 91, 150, 0.1);
        }

        .group-container {
            margin-bottom: 35px;
            border: 1px solid #d1e3f6;
            border-radius: 8px;
            background: white;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 91, 150, 0.1);
        }

        .save-group-btn {
            background: #00a0e9;
            float: right;
        }

        .save-group-btn:hover {
            background: #0088c7;
        }

        #tableContainer {
            max-height: 650px;
            overflow-y: auto;
            margin-top: 25px;
            padding: 5px;
        }

        #tableContainer::-webkit-scrollbar {
            width: 8px;
        }

        #tableContainer::-webkit-scrollbar-track {
            background: #f0f8ff;
        }

        #tableContainer::-webkit-scrollbar-thumb {
            background: #0077cc;
            border-radius: 4px;
        }
        
        .file-input-container {
            margin-top: 15px;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 10px 15px;
            background: #0077cc;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .file-input-label:hover {
            background: #005fa3;
        }
        
        #excelFile {
            display: none;
        }
        
        #customCountContainer {
            display: none;
            margin-top: 10px;
        }
        
        #customCount {
            width: 200px;
        }

        /* Новые стили для выбора источника данных */
        .source-selector {
            margin-bottom: 20px;
            padding: 15px;
            background: #e6f2ff;
            border-radius: 8px;
            border: 1px solid #b8d4f0;
        }

        .source-buttons {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .source-btn {
            flex: 1;
            padding: 12px;
            font-size: 16px;
        }

        .source-btn.active {
            background: #005fa3;
            box-shadow: 0 0 0 2px #0077cc;
        }

        /* Стили для модального окна */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 25px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .file-upload-item {
            margin: 15px 0;
            padding: 15px;
            border: 2px dashed #b8d4f0;
            border-radius: 8px;
            background: #f9fbff;
        }

        .file-upload-item input {
            width: 100%;
            margin-bottom: 10px;
        }

        .add-file-btn {
            background: #28a745;
            margin-top: 15px;
        }

        .add-file-btn:hover {
            background: #218838;
        }

        .process-files-btn {
            background: #dc3545;
            margin-top: 20px;
        }

        .process-files-btn:hover {
            background: #c82333;
        }

        .modal-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #0077cc;
        }

        .modal-tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #e6f2ff;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }

        .modal-tab.active {
            background: #0077cc;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Настройка наклеек</h1>
    <p class="instructions">
        Для заполнения пустых ячеек в столбцах таблицы (квитанции, типы приборов, диапазоны):<br>
        1. Убедитесь, что есть две ячейки с одинаковой информацией (например: "Счетчик" ... [пусто] ... "Счетчик")<br>
        
        2. Нажмите "Заполнить пустые ячейки" - все промежуточные пустые ячейки заполнятся автоматически. (можно выполнять опирацию много раз)<br>
        Для группирования схожих по номерам квитанции, типам, диапазонам необходимо нажать на "Сгруппировать" и после будет доступна возможность выгрузить массив через кнопку "сохранить группу"<br>
        
        3. В истоичнике данных выбиралем откуда будут задействоваться протоколы и создаём таблицу.<br>
После нажимаем кнопку Загрузить данные из Excel (формат файла .xlsx) или Загрузить данные из World (формат файла .docx)<br>
В появивщемся окне загружаем файлы в той последовательности в которая должна быть так 1 файл будет загружать с указанной вами 1 наклейки.<br>
Для добавление файла 2 нужно нажать в появившемся окне Добавить ещё файл или если нет необходимости завершаем загрузку нажав на кнопку Обработать файлы.<br>
    </p>

    <div class="source-selector">
        <label>Источник данных:</label>
        <div class="source-buttons">
            <button class="source-btn" id="vodokanalBtn" onclick="selectSource('vodokanal')">Водоканал</button>
            <button class="source-btn" id="unicomBtn" onclick="selectSource('unicom')">Уником</button>
        </div>
    </div>

    <div class="controls">
        <label for="stickerNumber">Начальный номер наклейки:</label>
        <input type="number" id="stickerNumber" min="1" required>
        <br>
        <label for="size">Размер наклейки:</label>
        <select id="size">
            <option value="16">16 мм (64 наклейки)</option>
            <option value="10">10 мм (144 наклейки)</option>
            <option value="custom">Свое количество</option>
        </select>
        <br>
        <div id="customCountContainer">
            <label for="customCount">Количество наклеек:</label>
            <input type="number" id="customCount" min="1" max="1000" value="100">
        </div>
        <button id="createTable">Создать таблицу</button>
        <button id="clearData" disabled>Очистить страницу</button>
        <button id="groupData" disabled>Сгруппировать</button>
        <button id="fillEmpty" disabled>Заполнить пустые ячейки</button>
        <button id="saveAll" disabled>Сохранить все данные</button>
        
        <!-- Кнопки для разных источников -->
        <div id="vodokanalControls" style="display: none;" class="file-input-container">
            <button onclick="openExcelUploadModal()">Загрузить данные из Excel</button>
        </div>
        
        <div id="unicomControls" style="display: none;" class="file-input-container">
            <button onclick="openWordUploadModal()">Загрузить данные из Word</button>
        </div>
    </div>

    <div id="tableContainer"></div>

    <!-- Модальное окно для загрузки Excel файлов -->
    <div id="excelUploadModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('excelUploadModal')">&times;</span>
            <h2>Загрузка файлов Excel (.xlsx)</h2>
            <p>Загружайте файлы по порядку. Данные будут добавлены в таблицу последовательно.</p>
            
            <div id="excelFileUploadContainer">
                <div class="file-upload-item">
                    <label>Файл 1:</label>
                    <input type="file" class="excel-file-input" accept=".xlsx" data-index="0">
                </div>
            </div>
            
            <button class="add-file-btn" onclick="addExcelFileInput()">+ Добавить еще файл</button>
            <button class="process-files-btn" onclick="processExcelFiles()">Обработать файлы</button>
        </div>
    </div>

    <!-- Модальное окно для загрузки Word файлов -->
    <div id="wordUploadModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('wordUploadModal')">&times;</span>
            <h2>Загрузка файлов Word (.docx)</h2>
            <p>Загружайте файлы по порядку. Данные будут добавлены в таблицу последовательно.</p>
            
            <div id="wordFileUploadContainer">
                <div class="file-upload-item">
                    <label>Файл 1:</label>
                    <input type="file" class="word-file-input" accept=".docx" data-index="0">
                </div>
            </div>
            
            <button class="add-file-btn" onclick="addWordFileInput()">+ Добавить еще файл</button>
            <button class="process-files-btn" onclick="processWordFiles()">Обработать файлы</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>

    <script>
        let isGrouped = false;
        let originalTableData = [];
        let currentSource = '';
        let nextExcelFileIndex = 1;
        let nextWordFileIndex = 1;

        document.addEventListener('DOMContentLoaded', function() {
            loadSavedData();

            document.getElementById('createTable').addEventListener('click', createTable);
            document.getElementById('clearData').addEventListener('click', clearData);
            document.getElementById('groupData').addEventListener('click', toggleGrouping);
            document.getElementById('fillEmpty').addEventListener('click', fillEmptyCells);
            document.getElementById('saveAll').addEventListener('click', exportAllToExcel);
            
            document.getElementById('size').addEventListener('change', function() {
                const customCountContainer = document.getElementById('customCountContainer');
                if (this.value === 'custom') {
                    customCountContainer.style.display = 'block';
                } else {
                    customCountContainer.style.display = 'none';
                }
            });
        });

        // ================== ФУНКЦИИ ДЛЯ ВЫБОРА ИСТОЧНИКА ==================
        function selectSource(source) {
            currentSource = source;
            
            document.getElementById('vodokanalBtn').classList.remove('active');
            document.getElementById('unicomBtn').classList.remove('active');
            
            document.getElementById('vodokanalControls').style.display = 'none';
            document.getElementById('unicomControls').style.display = 'none';
            
            if (source === 'vodokanal') {
                document.getElementById('vodokanalBtn').classList.add('active');
                document.getElementById('vodokanalControls').style.display = 'block';
            } else if (source === 'unicom') {
                document.getElementById('unicomBtn').classList.add('active');
                document.getElementById('unicomControls').style.display = 'block';
            }
        }

        // ================== ФУНКЦИИ ДЛЯ EXCEL ==================
        function openExcelUploadModal() {
            const table = document.getElementById('outputTable');
            if (!table) {
                alert('Сначала создайте таблицу!');
                return;
            }
            
            document.getElementById('excelUploadModal').style.display = 'block';
            document.getElementById('excelFileUploadContainer').innerHTML = `
                <div class="file-upload-item">
                    <label>Файл 1:</label>
                    <input type="file" class="excel-file-input" accept=".xlsx" data-index="0">
                </div>
            `;
            nextExcelFileIndex = 1;
        }

        function addExcelFileInput() {
            const container = document.getElementById('excelFileUploadContainer');
            const newIndex = nextExcelFileIndex++;
            
            const newFileInput = document.createElement('div');
            newFileInput.className = 'file-upload-item';
            newFileInput.innerHTML = `
                <label>Файл ${newIndex + 1}:</label>
                <input type="file" class="excel-file-input" accept=".xlsx" data-index="${newIndex}">
            `;
            
            container.appendChild(newFileInput);
        }

        function processExcelFiles() {
            const fileInputs = document.querySelectorAll('.excel-file-input');
            const files = Array.from(fileInputs)
                .map(input => input.files[0])
                .filter(file => file);
            
            if (files.length === 0) {
                alert('Пожалуйста, выберите хотя бы один файл');
                return;
            }

            processExcelFilesSequentially(files)
                .then(() => {
                    alert('Все Excel файлы успешно обработаны!');
                    closeModal('excelUploadModal');
                })
                .catch(error => {
                    console.error('Ошибка обработки Excel файлов:', error);
                    alert('Произошла ошибка при обработке Excel файлов');
                });
        }

        async function processExcelFilesSequentially(files) {
            const table = document.getElementById('outputTable');
            if (!table) throw new Error('Таблица не найдена');
            
            const rows = table.querySelectorAll('tbody tr');
            let currentRowIndex = 0;
            
            // Находим первую полностью пустую строку
            for (let i = 0; i < rows.length; i++) {
                const deviceTypeCell = rows[i].cells[3];
                const deviceNumberCell = rows[i].cells[4];
                
                if (!deviceTypeCell.textContent.trim() && !deviceNumberCell.textContent.trim()) {
                    currentRowIndex = i;
                    break;
                }
                
                if (i === rows.length - 1) {
                    alert('Все строки в таблице уже заполнены!');
                    return;
                }
            }
            
            for (const file of files) {
                if (!file.name.endsWith('.xlsx')) {
                    alert(`Файл "${file.name}" не является .xlsx файлом. Пропускаем.`);
                    continue;
                }
                
                const data = await parseExcelFile(file);
                
                // Заполняем таблицу данными из файла
                for (const item of data) {
                    if (currentRowIndex >= rows.length) {
                        alert('Достигнут конец таблицы. Не все данные были добавлены.');
                        break;
                    }
                    
                    const row = rows[currentRowIndex];
                    if (item.deviceType && row.cells[3]) {
                        row.cells[3].textContent = item.deviceType;
                    }
                    if (item.deviceNumber && row.cells[4]) {
                        row.cells[4].textContent = item.deviceNumber;
                    }
                    if (item.range && row.cells[5]) {
                        row.cells[5].textContent = item.range;
                    }
                    
                    currentRowIndex++;
                }
            }
            
            saveDataToLocalStorage();
        }

        function parseExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                        
                        const extractedData = extractDataFromExcel(jsonData);
                        resolve(extractedData);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = function(error) {
                    reject(error);
                };
                
                reader.readAsArrayBuffer(file);
            });
        }

        function extractDataFromExcel(excelData) {
            const extractedData = [];
            
            // Номера приборов (B4-23, G4-23, L4-23, B27-46, G27-46, L27-46)
            const deviceNumbers = [];
            // Типы приборов (C4-23, H4-23, M4-23, C27-46, H27-46, M27-46)
            const deviceTypes = [];
            // Диапазоны (E4-23, J4-23, O4-23, E27-46, J27-46, O27-46)
            const ranges = [];
            
            for (let row = 3; row < 23; row++) {
                if (excelData[row] && excelData[row][1]) deviceNumbers.push(excelData[row][1]);
                if (excelData[row] && excelData[row][2]) deviceTypes.push(excelData[row][2]);
                if (excelData[row] && excelData[row][4]) ranges.push(excelData[row][4]);
            }
            for (let row = 3; row < 23; row++) {
                if (excelData[row] && excelData[row][6]) deviceNumbers.push(excelData[row][6]);
                if (excelData[row] && excelData[row][7]) deviceTypes.push(excelData[row][7]);
                if (excelData[row] && excelData[row][9]) ranges.push(excelData[row][9]);
            }
            for (let row = 3; row < 23; row++) {
                if (excelData[row] && excelData[row][11]) deviceNumbers.push(excelData[row][11]);
                if (excelData[row] && excelData[row][12]) deviceTypes.push(excelData[row][12]);
                if (excelData[row] && excelData[row][14]) ranges.push(excelData[row][14]);
            }
            for (let row = 26; row < 46; row++) {
                if (excelData[row] && excelData[row][1]) deviceNumbers.push(excelData[row][1]);
                if (excelData[row] && excelData[row][2]) deviceTypes.push(excelData[row][2]);
                if (excelData[row] && excelData[row][4]) ranges.push(excelData[row][4]);
            }
            for (let row = 26; row < 46; row++) {
                if (excelData[row] && excelData[row][6]) deviceNumbers.push(excelData[row][6]);
                if (excelData[row] && excelData[row][7]) deviceTypes.push(excelData[row][7]);
                if (excelData[row] && excelData[row][9]) ranges.push(excelData[row][9]);
            }
            for (let row = 26; row < 46; row++) {
                if (excelData[row] && excelData[row][11]) deviceNumbers.push(excelData[row][11]);
                if (excelData[row] && excelData[row][12]) deviceTypes.push(excelData[row][12]);
                if (excelData[row] && excelData[row][14]) ranges.push(excelData[row][14]);
            }
            
            // Объединяем данные в один массив объектов
            const maxLength = Math.max(deviceNumbers.length, deviceTypes.length, ranges.length);
            
            for (let i = 0; i < maxLength; i++) {
                extractedData.push({
                    deviceNumber: deviceNumbers[i] || '',
                    deviceType: deviceTypes[i] || '',
                    range: ranges[i] || ''
                });
            }
            
            return extractedData;
        }

        // ================== ФУНКЦИИ ДЛЯ WORD ==================
        function openWordUploadModal() {
            const table = document.getElementById('outputTable');
            if (!table) {
                alert('Сначала создайте таблицу!');
                return;
            }
            
            document.getElementById('wordUploadModal').style.display = 'block';
            document.getElementById('wordFileUploadContainer').innerHTML = `
                <div class="file-upload-item">
                    <label>Файл 1:</label>
                    <input type="file" class="word-file-input" accept=".docx" data-index="0">
                </div>
            `;
            nextWordFileIndex = 1;
        }

        function addWordFileInput() {
            const container = document.getElementById('wordFileUploadContainer');
            const newIndex = nextWordFileIndex++;
            
            const newFileInput = document.createElement('div');
            newFileInput.className = 'file-upload-item';
            newFileInput.innerHTML = `
                <label>Файл ${newIndex + 1}:</label>
                <input type="file" class="word-file-input" accept=".docx" data-index="${newIndex}">
            `;
            
            container.appendChild(newFileInput);
        }

        function processWordFiles() {
            const fileInputs = document.querySelectorAll('.word-file-input');
            const files = Array.from(fileInputs)
                .map(input => input.files[0])
                .filter(file => file);
            
            if (files.length === 0) {
                alert('Пожалуйста, выберите хотя бы один файл');
                return;
            }

            processWordFilesSequentially(files)
                .then(() => {
                    alert('Все Word файлы успешно обработаны!');
                    closeModal('wordUploadModal');
                })
                .catch(error => {
                    console.error('Ошибка обработки Word файлов:', error);
                    alert('Произошла ошибка при обработке Word файлов');
                });
        }

        async function processWordFilesSequentially(files) {
            const table = document.getElementById('outputTable');
            if (!table) throw new Error('Таблица не найдена');
            
            const rows = table.querySelectorAll('tbody tr');
            let currentRowIndex = 0;
            
            // Находим первую полностью пустую строку
            for (let i = 0; i < rows.length; i++) {
                const deviceTypeCell = rows[i].cells[3];
                const deviceNumberCell = rows[i].cells[4];
                
                if (!deviceTypeCell.textContent.trim() && !deviceNumberCell.textContent.trim()) {
                    currentRowIndex = i;
                    break;
                }
                
                if (i === rows.length - 1) {
                    alert('Все строки в таблице уже заполнены!');
                    return;
                }
            }
            
            for (const file of files) {
                if (!file.name.endsWith('.docx')) {
                    alert(`Файл "${file.name}" не является .docx файлом. Пропускаем.`);
                    continue;
                }
                
                const data = await parseDocxFile(file);
                
                // Заполняем таблицу данными из файла
                for (const item of data) {
                    if (currentRowIndex >= rows.length) {
                        alert('Достигнут конец таблицы. Не все данные были добавлены.');
                        break;
                    }
                    
                    const row = rows[currentRowIndex];
                    row.cells[3].textContent = item.meterModel; // Тип прибора
                    row.cells[4].textContent = item.serialNumber; // Номер прибора
                    
                    currentRowIndex++;
                }
            }
            
            saveDataToLocalStorage();
        }

        function parseDocxFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    const arrayBuffer = event.target.result;
                    
                    mammoth.convertToHtml({ arrayBuffer: arrayBuffer })
                        .then(function(result) {
                            const data = extractDataFromDocxHtml(result.value);
                            resolve(data);
                        })
                        .catch(function(err) {
                            reject(err);
                        });
                };
                
                reader.onerror = function(error) {
                    reject(error);
                };
                
                reader.readAsArrayBuffer(file);
            });
        }

        function extractDataFromDocxHtml(html) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            const tables = tempDiv.getElementsByTagName('table');
            if (tables.length === 0) {
                return [];
            }

            const extractedData = [];
            const table = tables[0];
            const rows = table.getElementsByTagName('tr');

            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                
                if (cells.length >= 3) {
                    const serialNumber = cells[1].textContent.trim();
                    const meterModel = cells[2].textContent.trim();
                    
                    if (serialNumber && meterModel) {
                        extractedData.push({ serialNumber, meterModel });
                    }
                }
            }

            return extractedData;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // ================== ВАШИ ОРИГИНАЛЬНЫЕ ФУНКЦИИ ==================
        function createTable() {
            const stickerNumber = parseInt(document.getElementById('stickerNumber').value);
            const size = document.getElementById('size').value;
            let totalRows;

            if (isNaN(stickerNumber)) {
                alert('Пожалуйста, введите начальный номер наклейки');
                return;
            }

            if (size === "16") {
                totalRows = 64;
            } else if (size === "10") {
                totalRows = 144;
            } else if (size === "custom") {
                totalRows = parseInt(document.getElementById('customCount').value);
                if (isNaN(totalRows) || totalRows < 1) {
                    alert('Пожалуйста, введите корректное количество наклеек');
                    return;
                }
            }

            const tableContainer = document.getElementById('tableContainer');
            tableContainer.innerHTML = '';

            let tableHTML = `
                <table id="outputTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Номер наклейки</th>
                            <th>Номер квитанции</th>
                            <th>Тип прибора</th>
                            <th>Номер прибора</th>
                            <th>Диапазон</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            for (let i = 0; i < totalRows; i++) {
                tableHTML += `
                    <tr data-original-index="${i}">
                        <td>${i + 1}</td>
                        <td>${stickerNumber + i}</td>
                        <td class="editable account-number" contenteditable="true"></td>
                        <td class="editable device-type" contenteditable="true"></td>
                        <td class="editable device-number" contenteditable="true"></td>
                        <td class="editable range" contenteditable="true"></td>
                    </tr>
                `;
            }

            tableHTML += `</tbody></table>`;
            tableContainer.innerHTML = tableHTML;

            document.getElementById('clearData').disabled = false;
            document.getElementById('groupData').disabled = false;
            document.getElementById('fillEmpty').disabled = false;
            document.getElementById('saveAll').disabled = false;

            saveDataToLocalStorage();
            setupEditableCells();
        }

        function setupEditableCells() {
            const cells = document.querySelectorAll('td[contenteditable="true"]');

            cells.forEach(cell => {
                cell.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const row = cell.parentNode;
                        const nextRow = row.nextElementSibling;

                        if (nextRow) {
                            const cellIndex = Array.from(row.cells).indexOf(cell);
                            nextRow.cells[cellIndex].focus();
                        }
                    }
                });

                cell.addEventListener('blur', saveDataToLocalStorage);
            });
        }

        function fillEmptyCells() {
            const table = document.getElementById('outputTable');
            if (!table) return;

            const rows = Array.from(table.querySelectorAll('tbody tr'));
            let filledDeviceNumbers = 0;
            let filledAccounts = 0;
            let filledDeviceTypes = 0;
            let filledRanges = 0;

            // 1. Заполняем номера приборов (если пустые - номером наклейки)
            rows.forEach(row => {
                const stickerNum = row.cells[1].textContent;
                const deviceNumCell = row.cells[4];

                if (!deviceNumCell.textContent.trim()) {
                    deviceNumCell.textContent = stickerNum;
                    filledDeviceNumbers++;
                }
            });

            // 2. Заполняем пустые ячейки для каждого столбца (квитанции, типы, диапазоны)
            const columns = [
                { index: 2, name: "квитанции", count: 0 },
                { index: 3, name: "типы приборов", count: 0 },
                { index: 5, name: "диапазоны", count: 0 }
            ];

            columns.forEach(col => {
                const filledPositions = [];
                rows.forEach((row, idx) => {
                    const cell = row.cells[col.index];
                    if (cell.textContent.trim()) {
                        filledPositions.push({
                            index: idx,
                            value: cell.textContent.trim()
                        });
                    }
                });

                for (let i = 0; i < filledPositions.length - 1; i++) {
                    const current = filledPositions[i];
                    const next = filledPositions[i + 1];

                    if (current.value === next.value) {
                        for (let j = current.index + 1; j < next.index; j++) {
                            const cell = rows[j].cells[col.index];
                            if (!cell.textContent.trim()) {
                                cell.textContent = current.value;
                                col.count++;
                            }
                        }
                    }
                }
            });

            filledAccounts = columns[0].count;
            filledDeviceTypes = columns[1].count;
            filledRanges = columns[2].count;

            if (filledDeviceNumbers > 0 || filledAccounts > 0 || filledDeviceTypes > 0 || filledRanges > 0) {
                saveDataToLocalStorage();
                let message = "Заполнено ячеек:\n";
                if (filledDeviceNumbers > 0) message += `- Номера приборов: ${filledDeviceNumbers}\n`;
                if (filledAccounts > 0) message += `- Номера квитанций: ${filledAccounts}\n`;
                if (filledDeviceTypes > 0) message += `- Типы приборов: ${filledDeviceTypes}\n`;
                if (filledRanges > 0) message += `- Диапазоны: ${filledRanges}`;
                alert(message);
            } else {
                alert("Нет ячеек для заполнения по заданным правилам");
            }
        }

        function toggleGrouping() {
            if (isGrouped) {
                restoreOriginalTable();
            } else {
                groupData();
            }
        }

        function groupData() {
            const table = document.getElementById('outputTable');
            if (!table) return;

            originalTableData = Array.from(table.rows).map(row => Array.from(row.cells).map(cell => cell.innerHTML));

            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const groups = {};

            rows.forEach(row => {
                const account = row.cells[2].textContent.trim();
                const deviceType = row.cells[3].textContent.trim();
                const range = row.cells[5].textContent.trim();

                if (!account && !deviceType && !range) return;

                const groupKey = `${account || 'Без номера'}|${deviceType || 'Без типа'}|${range || 'Без диапазона'}`;

                if (!groups[groupKey]) {
                    groups[groupKey] = {
                        account: account,
                        deviceType: deviceType,
                        range: range,
                        rows: []
                    };
                }

                groups[groupKey].rows.push(row.outerHTML);
            });

            const tableContainer = document.getElementById('tableContainer');
            tableContainer.innerHTML = '';

            for (const [key, group] of Object.entries(groups)) {
                const groupContainer = document.createElement('div');
                groupContainer.className = 'group-container';

                const [account, deviceType, range] = key.split('|');

                groupContainer.innerHTML = `
                    <div class="group-header">
                        Номер квитанции: ${account} | 
                        Тип прибора: ${deviceType} | 
                        Диапазон: ${range}
                        <button class="save-group-btn" 
                                data-account="${account}" 
                                data-device-type="${deviceType}" 
                                data-range="${range}">
                            Сохранить группу
                        </button>
                    </div>
                    <table class="group-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Номер наклейки</th>
                                <th>Номер квитанции</th>
                                <th>Тип прибора</th>
                                <th>Номер прибора</th>
                                <th>Диапазон</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${group.rows.join('')}
                        </tbody>
                    </table>
                `;

                tableContainer.appendChild(groupContainer);
            }

            document.querySelectorAll('.save-group-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const account = this.getAttribute('data-account');
                    const deviceType = this.getAttribute('data-device-type');
                    const range = this.getAttribute('data-range');
                    const groupTable = this.closest('.group-container').querySelector('.group-table');
                    exportGroupToExcel(groupTable, account, deviceType, range);
                });
            });

            isGrouped = true;
            document.getElementById('groupData').textContent = 'Вернуться к таблице';
            document.getElementById('fillEmpty').disabled = true;
        }

        function restoreOriginalTable() {
            if (!originalTableData.length) return;

            const tableContainer = document.getElementById('tableContainer');
            tableContainer.innerHTML = `
                <table id="outputTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Номер наклейки</th>
                            <th>Номер квитанции</th>
                            <th>Тип прибора</th>
                            <th>Номер прибора</th>
                            <th>Диапазон</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${originalTableData.slice(1).map(row => `
                            <tr>
                                ${row.map((cell, i) => 
                                    i > 0 ? `<td class="${i === 2 ? 'account-number' : i === 3 ? 'device-type' : i === 4 ? 'device-number' : i === 5 ? 'range' : ''} ${i > 1 ? 'editable' : ''}" ${i > 1 ? 'contenteditable="true"' : ''}>${cell}</td>` 
                                    : `<td>${cell}</td>`
                                ).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            setupEditableCells();
            isGrouped = false;
            document.getElementById('groupData').textContent = 'Сгруппировать';
            document.getElementById('fillEmpty').disabled = false;
        }

        function exportGroupToExcel(table, account, deviceType, range) {
            const wb = XLSX.utils.book_new();
            const data = [['', '']];

            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.cells;
                data.push([
                    cells[1].textContent,
                    cells[4].textContent
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(data);
            XLSX.utils.book_append_sheet(wb, ws, 'Наклейки');

            const fileName = `Наклейки_${account || 'Без номера'}_${deviceType || 'Без типа'}_${range || 'Без диапазона'}`
                .replace(/[\/\\:*?"<>|]/g, '')
                .replace(/\s+/g, '_')
                .substring(0, 100) + '.xlsx';

            XLSX.writeFile(wb, fileName);
        }

        function exportAllToExcel() {
            const table = document.getElementById('outputTable');
            if (!table) return;

            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.table_to_sheet(table);
            XLSX.utils.book_append_sheet(wb, ws, 'Все наклейки');

            const stickerNumber = document.getElementById('stickerNumber').value;
            const size = document.getElementById('size').value;

            const fileName = `Наклейки_${stickerNumber}_${size}мм.xlsx`
                .replace(/[\/\\:*?"<>|]/g, '')
                .replace(/\s+/g, '_');

            XLSX.writeFile(wb, fileName);
        }

        function saveDataToLocalStorage() {
            const table = document.getElementById('outputTable');
            if (!table) return;

            const stickerNumber = document.getElementById('stickerNumber').value;
            const size = document.getElementById('size').value;
            const customCount = document.getElementById('customCount').value;

            localStorage.setItem('stickerNumber', stickerNumber);
            localStorage.setItem('size', size);
            localStorage.setItem('customCount', customCount);
            localStorage.setItem('stickerData', table.outerHTML);
        }

        function loadSavedData() {
            const savedData = localStorage.getItem('stickerData');
            if (savedData) {
                document.getElementById('tableContainer').innerHTML = savedData;
                document.getElementById('stickerNumber').value = localStorage.getItem('stickerNumber') || '';
                document.getElementById('size').value = localStorage.getItem('size') || '16';
                document.getElementById('customCount').value = localStorage.getItem('customCount') || '100';

                const customCountContainer = document.getElementById('customCountContainer');
                if (localStorage.getItem('size') === 'custom') {
                    customCountContainer.style.display = 'block';
                } else {
                    customCountContainer.style.display = 'none';
                }

                document.getElementById('clearData').disabled = false;
                document.getElementById('groupData').disabled = false;
                document.getElementById('fillEmpty').disabled = false;
                document.getElementById('saveAll').disabled = false;

                setupEditableCells();
            }
        }

        function clearData() {
            if (!confirm('Вы уверены, что хотите очистить все данные?')) return;

            localStorage.removeItem('stickerData');
            localStorage.removeItem('stickerNumber');
            localStorage.removeItem('size');
            localStorage.removeItem('customCount');
            document.getElementById('tableContainer').innerHTML = '';
            document.getElementById('clearData').disabled = true;
            document.getElementById('groupData').disabled = true;
            document.getElementById('fillEmpty').disabled = true;
            document.getElementById('saveAll').disabled = true;
            document.getElementById('groupData').textContent = 'Сгруппировать';
            isGrouped = false;
            originalTableData = [];
        }

        // Закрытие модального окна при клике вне его
        window.onclick = function(event) {
            const excelModal = document.getElementById('excelUploadModal');
            const wordModal = document.getElementById('wordUploadModal');
            
            if (event.target === excelModal) {
                closeModal('excelUploadModal');
            }
            if (event.target === wordModal) {
                closeModal('wordUploadModal');
            }
        };
    </script>
</body>
</html>
